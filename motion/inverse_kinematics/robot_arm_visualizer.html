<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>로봇팔 시각화</title>

    <!--
    ========================================
    로봇팔 시각화 시스템
    ========================================
    
    이 HTML 파일은 3링크 로봇팔의 동작을
    실시간으로 시각화하고 시뮬레이션하는
    웹 애플리케이션입니다.
    
    주요 기능:
    - 실시간 로봇팔 3D 시각화
    - 역기구학 계산 및 검증
    - 각도별 동작 시뮬레이션
    - 좌표 기반 위치 제어
    
    작성자: [사용자명]
    날짜: [작성일]
    ========================================
    -->

    <style>
        /*
         * ========================================
         * CSS 스타일 정의
         * ========================================
         * 
         * 전체 페이지의 레이아웃과 디자인을 정의합니다.
         * 반응형 디자인을 위해 flexbox를 사용하고,
         * 사용자 친화적인 인터페이스를 제공합니다.
         * ========================================
         */

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }

        /*
         * 메인 컨테이너 스타일
         * 전체 콘텐츠를 감싸는 중앙 정렬된 박스
         */
        .container {
            max-width: 1200px;
            /* 최대 너비 제한 */
            margin: 0 auto;
            /* 중앙 정렬 */
            background: white;
            /* 흰색 배경 */
            padding: 20px;
            /* 내부 여백 */
            border-radius: 10px;
            /* 둥근 모서리 */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            /* 그림자 효과 */
        }

        /*
         * 메인 제목 스타일
         * 페이지 상단의 로봇팔 시각화 제목
         */
        h1 {
            color: #333;
            /* 진한 회색 텍스트 */
            text-align: center;
            /* 중앙 정렬 */
            margin-bottom: 30px;
            /* 하단 여백 */
        }

        /*
         * 컨트롤 패널 레이아웃
         * 입력 필드들을 가로로 배치하는 flexbox 컨테이너
         */
        .controls {
            display: flex;
            /* flexbox 레이아웃 */
            gap: 20px;
            /* 요소 간 간격 */
            margin-bottom: 20px;
            /* 하단 여백 */
            flex-wrap: wrap;
            /* 화면이 작을 때 줄바꿈 */
        }

        /*
         * 개별 컨트롤 그룹
         * 각 입력 필드와 라벨을 그룹화
         */
        .control-group {
            flex: 1;
            /* 동일한 너비로 분배 */
            min-width: 200px;
            /* 최소 너비 보장 */
        }

        /*
         * 입력 필드 라벨
         * 각 입력 필드 위의 설명 텍스트
         */
        label {
            display: block;
            /* 블록 레벨 요소 */
            margin-bottom: 5px;
            /* 하단 여백 */
            font-weight: bold;
            /* 굵은 글씨 */
            color: #555;
            /* 중간 회색 */
        }

        /*
         * 숫자 입력 필드
         * 각도와 좌표 값을 입력받는 텍스트 박스
         */
        input[type="number"] {
            width: 100%;
            /* 부모 요소의 전체 너비 */
            padding: 8px;
            /* 내부 여백 */
            border: 1px solid #ddd;
            /* 테두리 */
            border-radius: 4px;
            /* 둥근 모서리 */
            font-size: 16px;
            /* 글씨 크기 */
        }

        /*
         * 버튼 스타일
         * 사용자 액션을 트리거하는 클릭 가능한 요소
         */
        button {
            background: #007bff;
            /* 파란색 배경 */
            color: white;
            /* 흰색 텍스트 */
            border: none;
            /* 테두리 없음 */
            padding: 10px 20px;
            /* 내부 여백 */
            border-radius: 4px;
            /* 둥근 모서리 */
            cursor: pointer;
            /* 마우스 포인터 */
            font-size: 16px;
            /* 글씨 크기 */
            margin: 5px;
            /* 외부 여백 */
        }

        /*
         * 버튼 호버 효과
         * 마우스를 올렸을 때의 시각적 피드백
         */
        button:hover {
            background: #0056b3;
            /* 더 진한 파란색 */
        }

        /*
         * 캔버스 컨테이너
         * 로봇팔 시각화를 위한 캔버스 영역
         */
        .canvas-container {
            text-align: center;
            /* 중앙 정렬 */
            margin: 20px 0;
            /* 상하 여백 */
        }

        /*
         * 캔버스 스타일
         * 로봇팔을 그리는 2D 그래픽 영역
         */
        canvas {
            border: 2px solid #333;
            /* 진한 회색 테두리 */
            background: #f8f9fa;
            /* 연한 회색 배경 */
        }

        /*
         * 정보 표시 영역
         * 로봇팔 사양과 현재 상태를 보여주는 박스
         */
        .info {
            background: #e9ecef;
            /* 연한 회색 배경 */
            padding: 15px;
            /* 내부 여백 */
            border-radius: 5px;
            /* 둥근 모서리 */
            margin: 20px 0;
            /* 상하 여백 */
        }

        /*
         * 좌표 정보 레이아웃
         * 여러 정보를 가로로 배치하는 flexbox
         */
        .coordinates {
            display: flex;
            /* flexbox 레이아웃 */
            gap: 20px;
            /* 요소 간 간격 */
            margin-top: 10px;
            /* 상단 여백 */
        }

        /*
         * 개별 좌표 정보 박스
         * 링크 길이, 각도, 위치 등의 정보를 표시
         */
        .coordinate {
            background: #fff;
            /* 흰색 배경 */
            padding: 10px;
            /* 내부 여백 */
            border-radius: 4px;
            /* 둥근 모서리 */
            border: 1px solid #ddd;
            /* 연한 회색 테두리 */
        }

        /*
         * 좌표 정보 제목
         * 각 정보 섹션의 제목 (예: "링크 길이", "현재 각도")
         */
        .coordinate h4 {
            margin: 0 0 5px 0;
            /* 하단 여백만 설정 */
            color: #333;
            /* 진한 회색 텍스트 */
        }

        /*
         * 좌표 정보 내용
         * 실제 수치 값을 표시하는 텍스트
         */
        .coordinate p {
            margin: 0;
            /* 여백 없음 */
            font-family: monospace;
            /* 고정폭 폰트 (숫자 정렬용) */
            font-size: 14px;
            /* 글씨 크기 */
        }
    </style>
</head>

<body>
    <!--
    ========================================
    메인 컨테이너
    ========================================
    전체 페이지 콘텐츠를 감싸는 중앙 정렬된 박스
    -->
    <div class="container">
        <!--
        메인 제목
        로봇팔 시각화 시스템의 제목과 이모지
        -->
        <h1>🤖 로봇팔 시각화 (YZ 평면)</h1>

        <!--
        ========================================
        컨트롤 패널
        ========================================
        사용자가 로봇팔을 제어할 수 있는 입력 필드들
        각도 제어와 좌표 제어 두 가지 방식을 제공
        -->
        <div class="controls">
            <!--
            어깨 관절 각도 제어
            Theta2는 어깨 관절의 pitch 방향 회전을 제어
            -90도 ~ +90도 범위로 제한
            -->
            <div class="control-group">
                <label for="theta2">Theta2 (어깨 관절) [도]:</label>
                <input type="number" id="theta2" value="0" min="-90" max="90" step="1">
            </div>

            <!--
            팔꿈치 관절 각도 제어
            Theta3는 팔꿈치 관절의 pitch 방향 회전을 제어
            -90도 ~ +90도 범위로 제한
            -->
            <div class="control-group">
                <label for="theta3">Theta3 (팔꿈치 관절) [도]:</label>
                <input type="number" id="theta3" value="0" min="-90" max="90" step="1">
            </div>

            <!--
            목표 Y 좌표 입력
            로봇팔이 도달해야 할 Y축 방향 위치 (전후 방향)
            양수 = 앞쪽, 음수 = 뒤쪽
            -->
            <div class="control-group">
                <label for="y">목표 Y 좌표 [mm]:</label>
                <input type="number" id="y" value="100" step="10">
            </div>

            <!--
            목표 Z 좌표 입력
            로봇팔이 도달해야 할 Z축 방향 위치 (상하 방향)
            양수 = 위쪽, 음수 = 아래쪽
            -->
            <div class="control-group">
                <label for="z">목표 Z 좌표 [mm]:</label>
                <input type="number" id="z" value="100" step="10">
            </div>
        </div>

        <!--
        ========================================
        제어 버튼
        ========================================
        로봇팔을 다양한 방식으로 제어할 수 있는 버튼들
        -->
        <div style="text-align: center;">
            <!--
            각도 기반 제어 버튼
            Theta2와 Theta3 입력 필드의 값을 사용하여
            로봇팔의 각도를 직접 제어
            -->
            <button onclick="updateFromAngles()">각도로 업데이트</button>

            <!--
            좌표 기반 제어 버튼
            Y, Z 좌표 입력 필드의 값을 사용하여
            역기구학으로 각도를 계산하고 로봇팔 제어
            -->
            <button onclick="updateFromCoordinates()">좌표로 업데이트</button>

            <!--
            초기화 버튼
            모든 입력 필드를 기본값으로 되돌리고
            로봇팔을 홈 포지션으로 이동
            -->
            <button onclick="resetPosition()">초기화</button>
        </div>

        <!--
        ========================================
        시각화 캔버스
        ========================================
        로봇팔의 실시간 상태를 2D 그래픽으로 표시
        YZ 평면에서의 투영을 보여줌
        -->
        <div class="canvas-container">
            <!--
            로봇팔 시각화를 위한 HTML5 Canvas 요소
            width: 800px, height: 600px로 설정
            JavaScript에서 이 캔버스에 로봇팔을 그림
            -->
            <canvas id="robotCanvas" width="800" height="600"></canvas>
        </div>

        <!--
        ========================================
        로봇팔 정보 표시
        ========================================
        로봇팔의 물리적 사양과 현재 상태를
        실시간으로 업데이트하여 표시
        -->
        <div class="info">
            <!--
            정보 섹션 제목
            로봇팔의 기본 사양과 동적 정보를 구분
            -->
            <h3>로봇팔 사양</h3>

            <!--
            정보 그리드 레이아웃
            여러 정보를 가로로 배치하여 한눈에 볼 수 있게 함
            -->
            <div class="coordinates">
                <!--
                링크 길이 정보
                로봇팔의 물리적 치수를 표시
                이 값들은 하드웨어 사양과 일치해야 함
                -->
                <div class="coordinate">
                    <h4>링크 길이</h4>
                    <p>L1 (베이스): 95mm</p>
                    <p>L2 (어깨): 123mm</p>
                    <p>L3 (팔꿈치): 200mm</p>
                </div>

                <!--
                현재 각도 정보
                실시간으로 업데이트되는 현재 관절 각도
                JavaScript에서 동적으로 값을 변경
                -->
                <div class="coordinate">
                    <h4>현재 각도</h4>
                    <p>Theta2: <span id="currentTheta2">0</span>°</p>
                    <p>Theta3: <span id="currentTheta3">0</span>°</p>
                </div>

                <!--
                엔드 이펙터 위치
                로봇팔 끝의 현재 Y, Z 좌표
                정기구학 계산 결과를 실시간 표시
                -->
                <div class="coordinate">
                    <h4>엔드 이펙터 위치</h4>
                    <p>Y: <span id="endY">0</span>mm</p>
                    <p>Z: <span id="endZ">0</span>mm</p>
                </div>

                <!--
                도달 가능 거리
                로봇팔이 물리적으로 도달할 수 있는 범위
                최소: |L2-L3|, 최대: L2+L3
                -->
                <div class="coordinate">
                    <h4>도달 거리</h4>
                    <p>최소: 77mm</p>
                    <p>최대: 323mm</p>
                </div>
            </div>
        </div>
    </div>

    <!--
    ========================================
    JavaScript 코드
    ========================================
    
    이 스크립트는 로봇팔의 시각화와 제어를 담당합니다.
    주요 기능:
    1. 정기구학: 각도 → 위치 계산
    2. 역기구학: 위치 → 각도 계산
    3. 실시간 시각화: Canvas 2D 그래픽
    4. 사용자 인터페이스: 입력 처리 및 업데이트
    
    수학적 배경:
    - 2링크 역기구학 (어깨 + 팔꿈치)
    - YZ 평면에서의 2D 시뮬레이션
    - 실시간 각도 및 위치 계산
    ========================================
    -->
    <script>
        /*
         * ========================================
         * 로봇팔 물리적 상수
         * ========================================
         * 
         * 이 값들은 실제 하드웨어의 치수와 정확히 일치해야 합니다.
         * Arduino 코드의 L1, L2, L3 값과 동일해야 함.
         * 
         * L1: 베이스에서 어깨 관절까지의 높이
         * L2: 어깨 관절에서 팔꿈치 관절까지의 링크 길이
         * L3: 팔꿈치 관절에서 엔드 이펙터까지의 링크 길이
         * 
         * 단위: 밀리미터 (mm)
         */
        const L1 = 95.0;   // 베이스 → 어깨 관절 높이 (mm)
        const L2 = 123.0;  // 어깨 관절 → 팔꿈치 관절 링크 길이 (mm)
        const L3 = 200.0;  // 팔꿈치 관절 → 엔드 이펙터 링크 길이 (mm)

        /*
         * ========================================
         * Canvas 그래픽 설정
         * ========================================
         * 
         * HTML5 Canvas를 사용하여 로봇팔을 2D로 시각화
         * 2D 컨텍스트를 통해 선, 원, 텍스트 등을 그릴 수 있음
         */
        const canvas = document.getElementById('robotCanvas');  // Canvas DOM 요소
        const ctx = canvas.getContext('2d');                   // 2D 그래픽 컨텍스트

        /*
         * ========================================
         * 좌표계 변환 설정
         * ========================================
         * 
         * 실제 물리적 좌표 (mm)를 Canvas 픽셀 좌표로 변환
         * 
         * scale: 1mm = 2px (확대 비율)
         * originX: Canvas의 X축 원점 (중앙)
         * originY: Canvas의 Y축 원점 (하단에서 50px 위)
         * 
         * 주의: Canvas의 Y축은 위에서 아래로 증가하므로,
         * 실제 물리적 Z축과는 반대 방향입니다.
         */
        const scale = 2;                    // 1mm = 2px (확대 비율)
        const originX = canvas.width / 2;   // X축 원점 (Canvas 중앙)
        const originY = canvas.height - 50; // Y축 원점 (Canvas 하단에서 50px 위)

        /*
         * ========================================
         * 전역 상태 변수
         * ========================================
         * 
         * 로봇팔의 현재 상태를 추적하는 변수들
         * 각도는 라디안 단위로 저장되며,
         * 사용자 인터페이스에서는 도 단위로 표시됩니다.
         */
        let currentTheta2 = 0;  // 어깨 관절 현재 각도 (라디안)
        let currentTheta3 = 0;  // 팔꿈치 관절 현재 각도 (라디안)

        /*
         * ========================================
         * 시스템 초기화
         * ========================================
         * 
         * 페이지 로드 시 한 번만 실행되는 초기화 함수
         * 로봇팔을 기본 홈 포지션으로 설정
         */
        function init() {
            updateFromAngles();  // 기본 각도로 초기화
        }

        /*
         * ========================================
         * Canvas 초기화
         * ========================================
         * 
         * Canvas를 완전히 지우고 깨끗한 상태로 만듦
         * 매번 로봇팔을 다시 그리기 전에 호출
         */
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // 전체 Canvas 영역 지우기
        }

        // 그리드 그리기
        function drawGrid() {
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;

            // Y축 그리드 (수직선)
            for (let y = -200; y <= 200; y += 50) {
                const x = originX + y * scale;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Z축 그리드 (수평선)
            for (let z = 0; z <= 400; z += 50) {
                const y = originY - z * scale;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // 축 그리기
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;

            // Y축
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, canvas.height);
            ctx.stroke();

            // Z축
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(canvas.width, originY);
            ctx.stroke();

            // 축 라벨
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.fillText('Y', originX + 10, 20);
            ctx.fillText('Z', canvas.width - 20, originY - 10);
        }

        // 좌표 변환 (실제 좌표 → 캔버스 좌표)
        function transformCoordinates(y, z) {
            return {
                x: originX + y * scale,
                y: originY - z * scale
            };
        }

        function forwardKinematics(theta2, theta3) {
            const t2 = theta2 * Math.PI / 180;
            const t3 = theta3 * Math.PI / 180;

            // 베이스 기준 위치 (L1 위에 shoulder 있음)
            const shoulderY = 0;
            const shoulderZ = L1;

            // 팔꿈치 위치
            const elbowY = shoulderY + L2 * Math.cos(t2);
            const elbowZ = shoulderZ + L2 * Math.sin(t2);

            // 엔드 이펙터 위치
            const endY = elbowY + L3 * Math.cos(t2 + t3);
            const endZ = elbowZ + L3 * Math.sin(t2 + t3);

            return {
                base: { y: 0, z: 0 },
                shoulder: { y: shoulderY, z: shoulderZ },
                elbow: { y: elbowY, z: elbowZ },
                end: { y: endY, z: endZ }
            };
        }

        function inverseKinematics(y, z) {
            const dy = y;
            const dz = z - L1;

            const rSquared = dy * dy + dz * dz;
            const D = (rSquared - L2 * L2 - L3 * L3) / (2 * L2 * L3);

            if (D < -1 || D > 1) return null; // 도달 불가

            const theta3_1 = Math.atan2(Math.sqrt(1 - D * D), D);   // elbow-down
            const theta3_2 = Math.atan2(-Math.sqrt(1 - D * D), D);  // elbow-up

            const theta2_1 = Math.atan2(dz, dy) - Math.atan2(L3 * Math.sin(theta3_1), L2 + L3 * Math.cos(theta3_1));
            const theta2_2 = Math.atan2(dz, dy) - Math.atan2(L3 * Math.sin(theta3_2), L2 + L3 * Math.cos(theta3_2));

            // 둘 중 theta2가 양수인 해 선택
            const theta2_deg_1 = theta2_1 * 180 / Math.PI;
            const theta2_deg_2 = theta2_2 * 180 / Math.PI;

            if (theta2_deg_1 > 0) {
                return {
                    theta2: theta2_deg_1,
                    theta3: theta3_1 * 180 / Math.PI
                };
            } else {
                return {
                    theta2: theta2_deg_2,
                    theta3: theta3_2 * 180 / Math.PI
                };
            }
        }







        // 로봇팔 그리기
        function drawRobotArm(positions) {
            // 베이스 그리기
            const base = transformCoordinates(positions.base.y, positions.base.z);
            ctx.fillStyle = '#666';
            ctx.fillRect(base.x - 10, base.y - 10, 20, 20);

            // 어깨 관절 그리기
            const shoulder = transformCoordinates(positions.shoulder.y, positions.shoulder.z);
            ctx.fillStyle = '#007bff';
            ctx.beginPath();
            ctx.arc(shoulder.x, shoulder.y, 8, 0, 2 * Math.PI);
            ctx.fill();

            // 팔꿈치 관절 그리기
            const elbow = transformCoordinates(positions.elbow.y, positions.elbow.z);
            ctx.fillStyle = '#28a745';
            ctx.beginPath();
            ctx.arc(elbow.x, elbow.y, 8, 0, 2 * Math.PI);
            ctx.fill();

            // 엔드 이펙터 그리기
            const end = transformCoordinates(positions.end.y, positions.end.z);
            ctx.fillStyle = '#dc3545';
            ctx.beginPath();
            ctx.arc(end.x, end.y, 10, 0, 2 * Math.PI);
            ctx.fill();

            // 링크 그리기
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;

            // 베이스 → 어깨
            ctx.beginPath();
            ctx.moveTo(base.x, base.y);
            ctx.lineTo(shoulder.x, shoulder.y);
            ctx.stroke();

            // 어깨 → 팔꿈치
            ctx.beginPath();
            ctx.moveTo(shoulder.x, shoulder.y);
            ctx.lineTo(elbow.x, elbow.y);
            ctx.stroke();

            // 팔꿈치 → 엔드
            ctx.beginPath();
            ctx.moveTo(elbow.x, elbow.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();

            // 좌표 라벨
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText(`(${positions.end.y.toFixed(1)}, ${positions.end.z.toFixed(1)})`, end.x + 15, end.y - 5);
        }

        // 목표 위치 표시
        function drawTarget(y, z) {
            const target = transformCoordinates(y, z);
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            // 십자 표시
            ctx.beginPath();
            ctx.moveTo(target.x - 15, target.y);
            ctx.lineTo(target.x + 15, target.y);
            ctx.moveTo(target.x, target.y - 15);
            ctx.lineTo(target.x, target.y + 15);
            ctx.stroke();

            ctx.setLineDash([]);

            // 라벨
            ctx.fillStyle = '#ffc107';
            ctx.font = '14px Arial';
            ctx.fillText(`목표: (${y}, ${z})`, target.x + 20, target.y - 10);
        }

        // 각도로 업데이트
        function updateFromAngles() {
            const theta2 = parseFloat(document.getElementById('theta2').value);
            const theta3 = parseFloat(document.getElementById('theta3').value);

            currentTheta2 = theta2;
            currentTheta3 = theta3;

            const positions = forwardKinematics(theta2, theta3);

            clearCanvas();
            drawGrid();
            drawRobotArm(positions);

            // 정보 업데이트
            document.getElementById('currentTheta2').textContent = theta2.toFixed(1);
            document.getElementById('currentTheta3').textContent = theta3.toFixed(1);
            document.getElementById('endY').textContent = positions.end.y.toFixed(1);
            document.getElementById('endZ').textContent = positions.end.z.toFixed(1);
        }

        // 좌표로 업데이트
        function updateFromCoordinates() {
            const y = parseFloat(document.getElementById('y').value);
            const z = parseFloat(document.getElementById('z').value);

            const angles = inverseKinematics(y, z);

            if (angles) {
                currentTheta2 = angles.theta2;
                currentTheta3 = angles.theta3;

                document.getElementById('theta2').value = angles.theta2.toFixed(1);
                document.getElementById('theta3').value = angles.theta3.toFixed(1);

                const positions = forwardKinematics(angles.theta2, angles.theta3);

                clearCanvas();
                drawGrid();
                drawRobotArm(positions);
                drawTarget(y, z);

                // 정보 업데이트
                document.getElementById('currentTheta2').textContent = angles.theta2.toFixed(1);
                document.getElementById('currentTheta3').textContent = angles.theta3.toFixed(1);
                document.getElementById('endY').textContent = positions.end.y.toFixed(1);
                document.getElementById('endZ').textContent = positions.end.z.toFixed(1);
            } else {
                alert('도달할 수 없는 위치입니다!');
            }
        }

        // 초기화
        function resetPosition() {
            document.getElementById('theta2').value = 0;
            document.getElementById('theta3').value = 0;
            document.getElementById('y').value = 100;
            document.getElementById('z').value = 100;
            updateFromAngles();
        }

        // 키보드 이벤트
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') {
                updateFromAngles();
            }
        });

        // 초기 실행
        init();
    </script>
</body>

</html>