<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>♔ 체스 로봇 - Stockfish와 대전</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .game-setup {
            background: #f8f9fa;
            padding: 30px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
        }

        .setup-options {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .option-group label {
            font-weight: bold;
            color: #495057;
        }

        .option-group select,
        .option-group input {
            padding: 10px 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 16px;
            background: white;
            transition: border-color 0.3s;
        }

        .option-group select:focus,
        .option-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .start-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            margin-top: 20px;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .game-board {
            padding: 30px;
            display: flex;
            gap: 30px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
        }

        .chess-board {
            width: 400px;
            height: 400px;
            border: 3px solid #2c3e50;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .board-row {
            display: flex;
            height: 50px;
        }

        .board-square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }

        .board-square.white {
            background-color: #f0d9b5;
        }

        .board-square.black {
            background-color: #b58863;
        }

        .board-square.selected {
            background-color: #7b61ff !important;
            color: white;
        }

        .board-square.legal-move {
            background-color: #90EE90 !important;
        }

        .board-square.legal-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.5);
        }

        .game-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            min-width: 300px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .status {
            font-size: 18px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            background: white;
        }

        /* 로그 모니터링 스타일 */
        .log-container {
            max-height: 200px;
            overflow-y: auto;
            background: #1e1e1e;
            color: #ffffff;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 10px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-time {
            color: #888;
            margin-right: 8px;
        }

        .log-info { color: #87CEEB; }
        .log-success { color: #90EE90; }
        .log-warning { color: #FFD700; }
        .log-error { color: #FF6B6B; }
        .log-data { color: #FFA500; }

        .move-item {
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #dee2e6;
        }

        .move-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #f1f3f4;
        }

        .move-item:last-child {
            border-bottom: none;
        }

        .move-number {
            font-weight: bold;
            color: #667eea;
        }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        .control-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .control-btn:hover {
            background: #5a6268;
        }

        .control-btn.primary {
            background: #28a745;
        }

        .control-btn.primary:hover {
            background: #218838;
        }

        .hidden {
            display: none;
        }

        .game-over {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-top: 20px;
        }

        .game-over h2 {
            margin-bottom: 10px;
        }

        /* 타이머 스타일 */
        .timer-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .timer-player {
            text-align: center;
            flex: 1;
        }

        .player-label {
            font-size: 14px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }

        .timer-display {
            font-size: 24px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #dee2e6;
        }

        /* 흰색 타이머 */
        #whiteTimer {
            background: #f0d9b5;
            border-color: #b58863;
            color: #2c3e50;
        }

        /* 검은색 타이머 */
        #blackTimer {
            background: #b58863;
            border-color: #2c3e50;
            color: #f0d9b5;
        }

        .timer-display.warning {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }

        .timer-display.danger {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        /* FEN 표시 스타일 */
        .fen-display {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            word-break: break-all;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .fen-display code {
            background: transparent;
            color: #3498db;
            font-weight: bold;
        }

        .fen-info {
            text-align: center;
            color: #7f8c8d;
            font-size: 11px;
        }

        /* 좌표 입력 스타일 */
        .coordinate-input {
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .coord-input {
            width: 60px;
            padding: 8px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-transform: lowercase;
        }

        .coord-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .arrow {
            font-size: 18px;
            color: #667eea;
            font-weight: bold;
        }

        .promotion-select {
            padding: 8px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            background: white;
            font-size: 12px;
        }

        .convert-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.3s;
        }

        .convert-btn:hover {
            transform: translateY(-2px);
        }

        .san-result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            min-height: 20px;
        }

        .san-result.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .san-result.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .info-text {
            text-align: center;
            margin: 10px 0;
            color: #667eea;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .chess-board {
                width: 320px;
                height: 320px;
            }

            .board-square {
                width: 40px;
                height: 40px;
                font-size: 24px;
            }

            .setup-options {
                flex-direction: column;
                gap: 20px;
            }

            .game-board {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>♔ 체스 로봇</h1>
            <p>Stockfish와 대전하는 체스 게임</p>
        </div>

        <div class="game-setup" id="gameSetup">
            <h2>게임 설정</h2>
            <div class="setup-options">
                <div class="option-group">
                    <label for="playerColor">내 색상 선택:</label>
                    <select id="playerColor">
                        <option value="white">흰색 (선수)</option>
                        <option value="black">검은색 (후수)</option>
                    </select>
                </div>
                <div class="option-group">
                    <label for="difficulty">난이도:</label>
                    <select id="difficulty">
                        <option value="5">초급 (5)</option>
                        <option value="10" selected>중급 (10)</option>
                        <option value="15">고급 (15)</option>
                        <option value="20">전문가 (20)</option>
                    </select>
                </div>
            </div>
            <button class="start-btn" onclick="startNewGame()">게임 시작</button>
        </div>

        <div class="game-board hidden" id="gameBoard">
            <div class="chess-board" id="chessBoard">
                <!-- 체스보드가 여기에 생성됩니다 -->
            </div>

            <div class="game-info">
                <div class="info-section">
                    <h3>게임 상태</h3>
                    <div class="status" id="gameStatus">게임 준비 중...</div>
                </div>

                <div class="info-section">
                    <h3>수 순서</h3>
                    <div id="currentTurn">흰색 차례</div>
                </div>

                <div class="info-section">
                    <h3>승리 가능성</h3>
                    <div id="winProbability">계산 중...</div>
                </div>

                <div class="info-section">
                    <h3>타이머</h3>
                    <div class="timer-container">
                        <div class="timer-player">
                            <div class="player-label">검은색</div>
                            <div class="timer-display" id="blackTimer">10:00</div>
                        </div>
                        <div class="timer-player">
                            <div class="player-label">흰색</div>
                            <div class="timer-display" id="whiteTimer">10:00</div>
                        </div>
                    </div>
                </div>

                <div class="info-section">
                    <h3>수 기록</h3>
                    <div class="move-history" id="moveHistory">
                        <div class="move-item">
                            <span>게임을 시작하세요</span>
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button class="control-btn" onclick="resetGame()">새 게임</button>
                    <button class="control-btn primary" onclick="undoMove()">무르기</button>
                    <button class="control-btn" onclick="startArduinoTimer()" id="arduinoTimerBtn" disabled>아두이노 타이머
                        시작</button>
                </div>

                <div class="info-section">
                    <h3>좌표 입력 (자동 방향 감지)</h3>
                    <div class="coordinate-input">
                        <div class="input-group">
                            <input type="text" id="fromCoord" placeholder="좌표 1 (예: e2)" maxlength="2"
                                class="coord-input">
                            <span class="arrow">↔</span>
                            <input type="text" id="toCoord" placeholder="좌표 2 (예: e4)" maxlength="2"
                                class="coord-input">
                            <select id="promotionPiece" class="promotion-select">
                                <option value="">승급</option>
                                <option value="q">퀸</option>
                                <option value="r">룩</option>
                                <option value="b">비숍</option>
                                <option value="n">나이트</option>
                            </select>
                        </div>
                        <button onclick="convertToSAN()" class="convert-btn">SAN 변환</button>
                        <div class="info-text">
                            <small>💡 두 좌표를 입력하면 자동으로 이동 방향을 감지합니다!</small>
                        </div>
                        <div id="sanResult" class="san-result"></div>
                    </div>
                </div>

                <div class="info-section">
                    <h3>FEN 표기법</h3>
                    <div class="fen-display" id="fenDisplay">
                        <code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1</code>
                    </div>
                    <div class="fen-info">
                        <small>FEN: Forsyth-Edwards Notation - 체스보드의 현재 상태를 표준 형식으로 표현</small>
                    </div>
                </div>

                <div class="game-over hidden" id="gameOver">
                    <h2>게임 종료!</h2>
                    <div id="gameResult"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentGame = null;
        let selectedSquare = null;
        let legalMoves = [];

        // 타이머 관련 변수
        let whiteTimer = 600; // 10분 = 600초
        let blackTimer = 600;
        let timerInterval = null;
        let websocket = null; // WebSocket 연결

        // Socket.IO 연결 설정
        function connectWebSocket() {
            try {
                // Socket.IO 클라이언트 초기화
                const socket = io();

                socket.on('connect', function () {
                    console.log('Socket.IO 연결 성공');
                    websocket = socket;

                    // 연결 성공 시 아두이노 타이머 버튼 활성화
                    const btn = document.getElementById('arduinoTimerBtn');
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = '아두이노 타이머 시작';
                        btn.style.background = '';
                    }
                });

                socket.on('timer_data', function (data) {
                    console.log('타이머 데이터 수신:', data);

                    // P1:시간,P2:시간 형식 파싱
                    if (data.startsWith('P1:') && data.includes(',P2:')) {
                        const parts = data.split(',');
                        if (parts.length === 2) {
                            try {
                                const p1Time = parseInt(parts[0].split(':')[1]);
                                const p2Time = parseInt(parts[1].split(':')[1]);

                                // 아두이노에서 받은 시간으로 타이머 업데이트
                                updateTimerFromArduino(p1Time, p2Time);
                            } catch (error) {
                                console.error('타이머 데이터 파싱 오류:', error);
                            }
                        }
                    }
                });

                socket.on('arduino_timer_response', function (data) {
                    console.log('아두이노 타이머 응답:', data);

                    if (data.status === 'started') {
                        console.log('아두이노 타이머 시작됨');
                    } else if (data.status === 'stopped') {
                        console.log('아두이노 타이머 정지됨');
                        // 버튼 상태 복원
                        const btn = document.getElementById('arduinoTimerBtn');
                        if (btn) {
                            btn.textContent = '아두이노 타이머 시작';
                            btn.disabled = false;
                            btn.style.background = '';
                        }
                    } else if (data.status === 'reset') {
                        console.log('아두이노 타이머 리셋됨');
                    } else if (data.status === 'error') {
                        console.error('아두이노 타이머 오류:', data.message);
                        alert('아두이노 타이머 오류: ' + data.message);
                        // 오류 시 버튼 상태 복원
                        const btn = document.getElementById('arduinoTimerBtn');
                        if (btn) {
                            btn.textContent = '아두이노 타이머 시작';
                            btn.disabled = false;
                            btn.style.background = '';
                        }
                    }
                });

                socket.on('disconnect', function () {
                    console.log('Socket.IO 연결 종료');
                    websocket = null;
                    // 재연결 시도
                    setTimeout(connectWebSocket, 3000);
                });

                socket.on('connect_error', function (error) {
                    console.error('Socket.IO 연결 오류:', error);
                });

            } catch (error) {
                console.error('Socket.IO 연결 실패:', error);
            }
        }

        // 아두이노에서 받은 타이머 데이터로 업데이트
        function updateTimerFromArduino(p1Time, p2Time) {
            // 아두이노의 P1은 검은색, P2는 흰색 (체스보드 기준)
            blackTimer = p1Time;
            whiteTimer = p2Time;

            // 타이머 표시 업데이트
            updateTimerDisplay();

            console.log(`아두이노 타이머 업데이트 - 검은색: ${blackTimer}초, 흰색: ${whiteTimer}초`);
        }

        // 체스 기물 유니코드
        const pieces = {
            'white': {
                'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
            },
            'black': {
                'P': '♟', 'R': '♜', 'N': '♞', 'B': '♝', 'Q': '♛', 'K': '♚'
            }
        };

        // 체스보드 초기화
        function initializeBoard() {
            const board = document.getElementById('chessBoard');
            board.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                const boardRow = document.createElement('div');
                boardRow.className = 'board-row';

                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const squareIndex = row * 8 + col;
                    const isWhite = (row + col) % 2 === 0;

                    square.className = `board-square ${isWhite ? 'white' : 'black'}`;
                    square.dataset.index = squareIndex;
                    square.onclick = () => handleSquareClick(squareIndex);

                    boardRow.appendChild(square);
                }

                board.appendChild(boardRow);
            }

            // 초기 기물 배치
            setupInitialPieces();
        }

        // 체스보드 업데이트
        function updateBoard(fen) {
            console.log('FEN 업데이트:', fen);
            const parts = fen.split(' ');
            const boardState = parts[0];
            console.log('보드 상태:', boardState);

            // 모든 칸 초기화
            const squares = document.querySelectorAll('.board-square');
            squares.forEach(square => {
                square.textContent = '';
                square.dataset.piece = '';
                square.dataset.color = '';
            });

            let squareIndex = 0;
            for (let char of boardState) {
                if (char === '/') continue;

                if (char >= '1' && char <= '8') {
                    squareIndex += parseInt(char);
                } else {
                    const color = char === char.toUpperCase() ? 'white' : 'black';
                    const piece = char.toUpperCase();
                    const square = document.querySelector(`[data-index="${squareIndex}"]`);

                    if (square) {
                        console.log(`칸 ${squareIndex}: ${color} ${piece}`);
                        square.textContent = pieces[color][piece];
                        square.dataset.piece = piece;
                        square.dataset.color = color;
                    }

                    squareIndex++;
                }
            }

            // 보드 업데이트 후 FEN과 승리 가능성 재계산
            updateFEN(fen);
            updateWinProbability();
        }

        // FEN을 체스보드에 직접 배치하는 함수
        function placePiecesFromFen(fen) {
            console.log('FEN에서 기물 배치 시작:', fen);

            // 모든 칸 초기화
            const squares = document.querySelectorAll('.board-square');
            squares.forEach(square => {
                square.textContent = '';
                square.dataset.piece = '';
                square.dataset.color = '';
            });

            const parts = fen.split(' ');
            const boardState = parts[0];

            let squareIndex = 0;
            for (let char of boardState) {
                if (char === '/') continue;

                if (char >= '1' && char <= '8') {
                    squareIndex += parseInt(char);
                } else {
                    const color = char === char.toUpperCase() ? 'white' : 'black';
                    const piece = char.toUpperCase();
                    const square = document.querySelector(`[data-index="${squareIndex}"]`);

                    if (square) {
                        console.log(`FEN 배치 - 칸 ${squareIndex}: ${color} ${piece}`);
                        square.textContent = pieces[color][piece];
                        square.dataset.piece = piece;
                        square.dataset.color = color;
                    }

                    squareIndex++;
                }
            }

            console.log('FEN에서 기물 배치 완료');

            // 기물 배치 후 승리 가능성 계산
            updateWinProbability();
        }

        // 초기 기물 배치 함수
        function setupInitialPieces() {
            console.log('초기 기물 배치 시작');

            // 초기 체스 기물 배치 (8x8 배열)
            const initialBoard = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],  // 8번째 줄 (검은색)
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],  // 7번째 줄 (검은색 폰)
                ['', '', '', '', '', '', '', ''],            // 6번째 줄 (빈칸)
                ['', '', '', '', '', '', '', ''],            // 5번째 줄 (빈칸)
                ['', '', '', '', '', '', '', ''],            // 4번째 줄 (빈칸)
                ['', '', '', '', '', '', '', ''],            // 3번째 줄 (빈칸)
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],  // 2번째 줄 (흰색 폰)
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']   // 1번째 줄 (흰색)
            ];

            // 각 칸에 기물 배치
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const squareIndex = row * 8 + col;
                    const piece = initialBoard[row][col];
                    const square = document.querySelector(`[data-index="${squareIndex}"]`);

                    if (square && piece !== '') {
                        const color = piece === piece.toUpperCase() ? 'white' : 'black';
                        const pieceType = piece.toUpperCase();

                        console.log(`칸 ${squareIndex} (${row},${col}): ${color} ${pieceType}`);
                        square.textContent = pieces[color][pieceType];
                        square.dataset.piece = pieceType;
                        square.dataset.color = color;
                    }
                }
            }

            console.log('초기 기물 배치 완료');
        }

        // 새 게임 시작
        function startNewGame() {
            const playerColor = document.getElementById('playerColor').value;
            const difficulty = document.getElementById('difficulty').value;

            fetch('/new_game', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    player_color: playerColor,
                    difficulty: parseInt(difficulty)
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentGame = data.game_id;
                        document.getElementById('gameSetup').classList.add('hidden');
                        document.getElementById('gameBoard').classList.remove('hidden');
                        document.getElementById('gameOver').classList.add('hidden');

                        updateGameState(data.board_state);
                        placePiecesFromFen(data.board_state.fen);

                        // WebSocket 연결 시작
                        connectWebSocket();

                        // WebSocket 연결 후 아두이노 타이머 시작
                        setTimeout(() => {
                            if (websocket && websocket.connected) {
                                startArduinoTimer();
                                console.log('게임 시작됨 - 아두이노 타이머 자동 시작');
                            } else {
                                console.log('WebSocket 연결 대기 중...');
                                // 연결이 안 되면 3초 후 다시 시도
                                setTimeout(() => {
                                    if (websocket && websocket.connected) {
                                        startArduinoTimer();
                                        console.log('게임 시작됨 - 아두이노 타이머 시작 (지연)');
                                    } else {
                                        console.log('WebSocket 연결 실패');
                                    }
                                }, 3000);
                            }
                        }, 1000);
                    }
                })
                .catch(error => {
                    console.error('게임 시작 오류:', error);
                    alert('게임을 시작할 수 없습니다.');
                });
        }

        // 게임 상태 업데이트
        function updateGameState(boardState) {
            const gameStatusDiv = document.getElementById('gameStatus');
            const currentTurnDiv = document.getElementById('currentTurn');

            if (boardState.game_over) {
                // 게임 종료 시 타이머 정지
                stopTimer();

                // 게임 종료 이유에 따른 상태 메시지 생성
                let statusMessage = '';
                let statusColor = '#e74c3c';

                if (boardState.result === '1-0') {
                    statusMessage = '게임 종료 - 흰색 승리! (체크메이트)';
                    statusColor = '#3498db';
                } else if (boardState.result === '0-1') {
                    statusMessage = '게임 종료 - 검은색 승리! (체크메이트)';
                    statusColor = '#2c3e50';
                } else if (boardState.result === '1/2-1/2') {
                    statusMessage = '게임 종료 - 무승부';
                    statusColor = '#95a5a6';
                } else {
                    statusMessage = '게임 종료';
                    statusColor = '#e74c3c';
                }

                gameStatusDiv.textContent = statusMessage;
                gameStatusDiv.style.color = statusColor;
                gameStatusDiv.style.fontWeight = 'bold';

                // 게임 종료 시 차례 표시 제거
                currentTurnDiv.textContent = '';

                // 게임 종료 이유 표시
                showGameOver(boardState.result);
            } else {
                gameStatusDiv.textContent = '게임 진행 중';
                gameStatusDiv.style.color = '#495057';
                gameStatusDiv.style.fontWeight = 'normal';

                currentTurnDiv.textContent =
                    `현재 차례: ${boardState.current_turn === 'white' ? '흰색' : '검은색'}`;
            }

            updateMoveHistory(boardState.move_history);

            // FEN 업데이트
            if (boardState.fen) {
                updateFEN(boardState.fen);
            }

            // 승리 가능성 업데이트
            updateWinProbability();
        }

        // 수 기록 업데이트
        function updateMoveHistory(moves) {
            const historyDiv = document.getElementById('moveHistory');
            historyDiv.innerHTML = '';

            if (moves.length === 0) {
                historyDiv.innerHTML = '<div class="move-item"><span>게임을 시작하세요</span></div>';
                return;
            }

            for (let i = 0; i < moves.length; i += 2) {
                const moveItem = document.createElement('div');
                moveItem.className = 'move-item';

                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = moves[i] ? moves[i].move : '';
                const blackMove = moves[i + 1] ? moves[i + 1].move : '';

                moveItem.innerHTML = `
                    <span class="move-number">${moveNumber}.</span>
                    <span>${whiteMove}</span>
                    <span>${blackMove}</span>
                `;

                historyDiv.appendChild(moveItem);
            }
        }

        // 게임 종료 표시
        function showGameOver(result) {
            const gameOverDiv = document.getElementById('gameOver');
            const resultDiv = document.getElementById('gameResult');

            let resultText = '';
            let resultColor = '';
            let resultDetails = '';
            let additionalInfo = '';

            if (result === '1-0') {
                resultText = '♔ 흰색 승리! ♔';
                resultColor = '#3498db';
                resultDetails = '체크메이트로 게임이 종료되었습니다.';
                additionalInfo = '흰색이 검은색의 킹을 체크메이트했습니다.';
            } else if (result === '0-1') {
                resultText = '♚ 검은색 승리! ♚';
                resultColor = '#2c3e50';
                resultDetails = '체크메이트로 게임이 종료되었습니다.';
                additionalInfo = '검은색이 흰색의 킹을 체크메이트했습니다.';
            } else if (result === '1/2-1/2') {
                resultText = '⚖️ 무승부! ⚖️';
                resultColor = '#95a5a6';
                resultDetails = '게임이 무승부로 종료되었습니다.';
                additionalInfo = '스테일메이트, 50수 규칙, 기물 부족, 반복 등으로 인한 무승부입니다.';
            } else {
                resultText = '🏁 게임 종료';
                resultColor = '#e74c3c';
                resultDetails = '게임이 종료되었습니다.';
                additionalInfo = '알 수 없는 이유로 게임이 종료되었습니다.';
            }

            resultDiv.innerHTML = `
                <div style="font-size: 24px; font-weight: bold; color: ${resultColor}; margin-bottom: 10px;">
                    ${resultText}
                </div>
                <div style="font-size: 14px; color: #7f8c8d; margin-bottom: 8px;">
                    ${resultDetails}
                </div>
                <div style="font-size: 12px; color: #95a5a6; font-style: italic;">
                    ${additionalInfo}
                </div>
            `;

            gameOverDiv.classList.remove('hidden');

            // 게임 종료 시 타이머 정지
            stopTimer();

            // 아두이노 타이머도 정지
            stopArduinoTimer();

            // 게임 종료 시 선택된 기물과 합법적인 이동 표시 제거
            clearSelection();
        }

        // 칸 클릭 처리
        function handleSquareClick(squareIndex) {
            if (!currentGame) return;

            // 게임이 종료되었는지 확인
            const gameStatus = document.getElementById('gameStatus').textContent;
            if (gameStatus === '게임 종료') {
                alert('게임이 이미 종료되었습니다. 새 게임을 시작해주세요.');
                return;
            }

            const square = document.querySelector(`[data-index="${squareIndex}"]`);

            // 이미 선택된 칸이 있는 경우
            if (selectedSquare !== null) {
                // 같은 칸을 클릭한 경우 선택 해제
                if (selectedSquare === squareIndex) {
                    clearSelection();
                    return;
                }

                // 이동 시도
                const fromSquare = selectedSquare;
                const toSquare = squareIndex;

                makeMove(fromSquare, toSquare);
                clearSelection();
                return;
            }

            // 새로운 칸 선택 - 현재 차례인 기물만 선택 가능
            if (square.dataset.piece) {
                const currentTurn = document.getElementById('currentTurn').textContent;
                const isWhiteTurn = currentTurn.includes('흰색');
                const pieceColor = square.dataset.color;

                // 현재 차례와 기물 색상이 일치하는지 확인
                if ((isWhiteTurn && pieceColor === 'white') || (!isWhiteTurn && pieceColor === 'black')) {
                    selectedSquare = squareIndex;
                    square.classList.add('selected');

                    // 합법적인 이동 표시
                    showLegalMoves(squareIndex);
                } else {
                    // 상대 차례의 기물을 클릭한 경우
                    alert('현재는 당신의 차례가 아닙니다.');
                }
            }
        }

        // 선택 해제
        function clearSelection() {
            if (selectedSquare !== null) {
                const square = document.querySelector(`[data-index="${selectedSquare}"]`);
                if (square) {
                    square.classList.remove('selected');
                }
                selectedSquare = null;

                // 합법적인 이동 표시 제거
                clearLegalMoves();
            }
        }

        // 합법적인 이동 표시
        function showLegalMoves(squareIndex) {
            // 현재 선택된 기물의 정보 가져오기
            const selectedSquare = document.querySelector(`[data-index="${squareIndex}"]`);
            if (!selectedSquare || !selectedSquare.dataset.piece) return;

            const selectedColor = selectedSquare.dataset.color;
            const pieceType = selectedSquare.dataset.piece;

            console.log(`기물 선택: ${pieceType} (${selectedColor}) at ${squareIndex}`);

            // 모든 칸에서 합법적인 이동 표시 제거
            clearLegalMoves();

            console.log(`현재 차례: ${document.getElementById('currentTurn').textContent}`);

            // 간단한 체스 규칙 기반 합법적인 이동 표시
            const squares = document.querySelectorAll('.board-square');
            let legalMoveCount = 0;

            squares.forEach(square => {
                const targetIndex = parseInt(square.dataset.index);
                if (targetIndex === squareIndex) return; // 같은 칸은 제외

                const targetPiece = square.dataset.piece;
                const targetColor = square.dataset.color;

                // 상대 기물이 있는 칸은 기물 잡기 가능
                if (targetPiece && targetColor !== selectedColor) {
                    if (isValidCapture(squareIndex, targetIndex, pieceType, selectedColor)) {
                        square.classList.add('legal-move');
                        legalMoveCount++;
                        console.log(`기물 잡기 가능: ${targetIndex} (${targetPiece})`);
                    } else {
                        console.log(`기물 잡기 불가: ${targetIndex} (${targetPiece}) - ${pieceType}으로는 잡을 수 없음`);
                    }
                }
                // 빈 칸은 이동 가능 여부 확인
                else if (!targetPiece) {
                    if (isValidMove(squareIndex, targetIndex, pieceType, selectedColor)) {
                        square.classList.add('legal-move');
                        legalMoveCount++;
                        console.log(`이동 가능: ${targetIndex}`);
                    } else {
                        console.log(`이동 불가: ${targetIndex} - ${pieceType}으로는 이동할 수 없음`);
                    }
                }
            });

            console.log(`총 ${legalMoveCount}개의 합법적인 이동 발견`);
        }

        // 정확한 체스 이동 유효성 검사
        function isValidMove(fromIndex, toIndex, pieceType, color) {
            const fromRow = Math.floor(fromIndex / 8);
            const fromCol = fromIndex % 8;
            const toRow = Math.floor(toIndex / 8);
            const toCol = toIndex % 8;

            // 폰 이동 규칙
            if (pieceType === 'P') {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;

                // 수직 이동
                if (fromCol === toCol) {
                    // 한 칸 이동
                    if (toRow === fromRow + direction) {
                        return !hasPieceAt(toIndex);
                    }
                    // 두 칸 이동 (시작 위치에서만)
                    if (fromRow === startRow && toRow === fromRow + 2 * direction) {
                        const middleRow = fromRow + direction;
                        return !hasPieceAt(middleRow * 8 + fromCol) && !hasPieceAt(toIndex);
                    }
                }
                return false;
            }

            // 룩 이동 규칙 (수직/수평)
            if (pieceType === 'R') {
                if (fromRow !== toRow && fromCol !== toCol) return false;
                return !hasObstacleBetween(fromIndex, toIndex);
            }

            // 비숍 이동 규칙 (대각선)
            if (pieceType === 'B') {
                if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
                return !hasObstacleBetween(fromIndex, toIndex);
            }

            // 나이트 이동 규칙 (L자)
            if (pieceType === 'N') {
                const rowDiff = Math.abs(fromRow - toRow);
                const colDiff = Math.abs(fromCol - toCol);
                const isValid = (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                console.log(`나이트 이동 검사: ${fromIndex} -> ${toIndex}, rowDiff: ${rowDiff}, colDiff: ${colDiff}, 유효: ${isValid}`);
                return isValid;
            }

            // 퀸 이동 규칙 (룩 + 비숍)
            if (pieceType === 'Q') {
                if (fromRow === toRow || fromCol === toCol) {
                    return !hasObstacleBetween(fromIndex, toIndex);
                }
                if (Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol)) {
                    return !hasObstacleBetween(fromIndex, toIndex);
                }
                return false;
            }

            // 킹 이동 규칙 (한 칸)
            if (pieceType === 'K') {
                return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
            }

            return false;
        }

        // 두 칸 사이에 장애물이 있는지 확인
        function hasObstacleBetween(fromIndex, toIndex) {
            const fromRow = Math.floor(fromIndex / 8);
            const fromCol = fromIndex % 8;
            const toRow = Math.floor(toIndex / 8);
            const toCol = toIndex % 8;

            // 수직 이동
            if (fromCol === toCol) {
                const startRow = Math.min(fromRow, toRow);
                const endRow = Math.max(fromRow, toRow);
                for (let row = startRow + 1; row < endRow; row++) {
                    if (hasPieceAt(row * 8 + fromCol)) return true;
                }
            }
            // 수평 이동
            else if (fromRow === toRow) {
                const startCol = Math.min(fromCol, toCol);
                const endCol = Math.max(fromCol, toCol);
                for (let col = startCol + 1; col < endCol; col++) {
                    if (hasPieceAt(fromRow * 8 + col)) return true;
                }
            }
            // 대각선 이동
            else {
                const rowStep = fromRow < toRow ? 1 : -1;
                const colStep = fromCol < toCol ? 1 : -1;
                let row = fromRow + rowStep;
                let col = fromCol + colStep;
                while (row !== toRow && col !== toCol) {
                    if (hasPieceAt(row * 8 + col)) return true;
                    row += rowStep;
                    col += colStep;
                }
            }
            return false;
        }

        // 기물 잡기 유효성 검사
        function isValidCapture(fromIndex, toIndex, pieceType, color) {
            const fromRow = Math.floor(fromIndex / 8);
            const fromCol = fromIndex % 8;
            const toRow = Math.floor(toIndex / 8);
            const toCol = toIndex % 8;

            // 폰 대각선 이동 (기물 잡기)
            if (pieceType === 'P') {
                const direction = color === 'white' ? -1 : 1;
                return Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction;
            }

            // 룩 기물 잡기 (수직/수평)
            if (pieceType === 'R') {
                if (fromRow !== toRow && fromCol !== toCol) return false;
                return !hasObstacleBetween(fromIndex, toIndex);
            }

            // 비숍 기물 잡기 (대각선)
            if (pieceType === 'B') {
                if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;
                return !hasObstacleBetween(fromIndex, toIndex);
            }

            // 나이트 기물 잡기 (L자)
            if (pieceType === 'N') {
                const rowDiff = Math.abs(fromRow - toRow);
                const colDiff = Math.abs(fromCol - toCol);
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }

            // 퀸 기물 잡기 (룩 + 비숍)
            if (pieceType === 'Q') {
                if (fromRow === toRow || fromCol === toCol) {
                    return !hasObstacleBetween(fromIndex, toIndex);
                }
                if (Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol)) {
                    return !hasObstacleBetween(fromIndex, toIndex);
                }
                return false;
            }

            // 킹 기물 잡기 (한 칸)
            if (pieceType === 'K') {
                return Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1;
            }

            return false;
        }

        // 특정 위치에 기물이 있는지 확인
        function hasPieceAt(index) {
            const square = document.querySelector(`[data-index="${index}"]`);
            return square && square.dataset.piece;
        }

        // 타이머 시작 (아두이노 데이터만 사용)
        function startTimer() {
            console.log('타이머 시작 - 아두이노 데이터 대기 중');
            // 아두이노에서 타이머 데이터를 보내주므로 자동 감소 로직 불필요
        }

        // 타이머 정지
        function stopTimer() {
            console.log('타이머 정지');
            // 아두이노 타이머는 계속 작동
        }

        // 타이머 리셋 (아두이노에서 초기화)
        function resetTimer() {
            console.log('타이머 리셋 - 아두이노에서 초기화됨');
            // 아두이노에서 10분(600초)으로 초기화
            whiteTimer = 600;
            blackTimer = 600;
            updateTimerDisplay();
        }

        // 시간 초과 처리 (아두이노에서 처리)
        function handleTimeOut() {
            // 아두이노에서 시간 초과를 감지하고 처리하므로 여기서는 로그만
            console.log('아두이노에서 시간 초과 처리됨');
        }

        // 아두이노 타이머 시작
        function startArduinoTimer() {
            console.log('아두이노 타이머 시작 요청');

            // WebSocket을 통해 아두이노에 타이머 시작 신호 전송
            if (websocket && websocket.connected) {
                websocket.emit('start_arduino_timer', {
                    action: 'start',
                    time: 600, // 10분
                    message: 'START_TIMER'
                });
                console.log('아두이노 타이머 시작 신호 전송됨');

                // 버튼 상태 변경
                const btn = document.getElementById('arduinoTimerBtn');
                btn.textContent = '타이머 실행 중...';
                btn.disabled = true;
                btn.style.background = '#28a745';
            } else {
                console.log('WebSocket 연결이 없습니다');
                alert('WebSocket 연결을 확인해주세요');
            }
        }

        // 아두이노 타이머 정지
        function stopArduinoTimer() {
            console.log('아두이노 타이머 정지 요청');

            if (websocket && websocket.connected) {
                websocket.emit('stop_arduino_timer', {
                    action: 'stop',
                    message: 'STOP_TIMER'
                });
                console.log('아두이노 타이머 정지 신호 전송됨');

                // 버튼 상태 복원
                const btn = document.getElementById('arduinoTimerBtn');
                btn.textContent = '아두이노 타이머 시작';
                btn.disabled = false;
                btn.style.background = '';
            }
        }

        // 아두이노 타이머 리셋
        function resetArduinoTimer() {
            console.log('아두이노 타이머 리셋 요청');

            if (websocket && websocket.connected) {
                websocket.emit('reset_arduino_timer', {
                    action: 'reset',
                    time: 600, // 10분으로 리셋
                    message: 'RESET_TIMER'
                });
                console.log('아두이노 타이머 리셋 신호 전송됨');
            }
        }

        // 타이머 표시 업데이트
        function updateTimerDisplay() {
            const whiteTimerDiv = document.getElementById('whiteTimer');
            const blackTimerDiv = document.getElementById('blackTimer');

            // 흰색 타이머
            const whiteMinutes = Math.floor(whiteTimer / 60);
            const whiteSeconds = whiteTimer % 60;
            whiteTimerDiv.textContent = `${whiteMinutes}:${whiteSeconds.toString().padStart(2, '0')}`;

            // 검은색 타이머
            const blackMinutes = Math.floor(blackTimer / 60);
            const blackSeconds = blackTimer % 60;
            blackTimerDiv.textContent = `${blackMinutes}:${blackSeconds.toString().padStart(2, '0')}`;

            // 경고 표시
            whiteTimerDiv.className = 'timer-display';
            blackTimerDiv.className = 'timer-display';

            if (whiteTimer <= 60) {
                whiteTimerDiv.classList.add(whiteTimer <= 30 ? 'danger' : 'warning');
            }
            if (blackTimer <= 60) {
                blackTimerDiv.classList.add(blackTimer <= 30 ? 'danger' : 'warning');
            }

            // 시간 초과 체크는 startTimer 함수에서 처리
        }



        // 승리 가능성 계산
        function calculateWinProbability() {
            const currentTurn = document.getElementById('currentTurn').textContent;
            const isWhiteTurn = currentTurn.includes('흰색');

            // 기물 가치 계산
            const pieceValues = {
                'P': 1,   // 폰
                'R': 5,   // 룩
                'N': 3,   // 나이트
                'B': 3,   // 비숍
                'Q': 9,   // 퀸
                'K': 0    // 킹 (게임에서 잃으면 끝)
            };

            let whiteMaterial = 0;
            let blackMaterial = 0;
            let whitePieces = 0;
            let blackPieces = 0;

            // 모든 칸을 검사하여 기물 가치 계산
            const squares = document.querySelectorAll('.board-square');
            squares.forEach(square => {
                const piece = square.dataset.piece;
                const color = square.dataset.color;

                if (piece && pieceValues[piece] !== undefined) {
                    if (color === 'white') {
                        whiteMaterial += pieceValues[piece];
                        whitePieces++;
                    } else {
                        blackMaterial += pieceValues[piece];
                        blackPieces++;
                    }
                }
            });

            // 체크메이트 상황 확인
            const gameStatus = document.getElementById('gameStatus').textContent;
            if (gameStatus.includes('게임 종료')) {
                const gameResult = document.getElementById('gameResult');
                if (gameResult) {
                    if (gameResult.textContent.includes('흰색 승리')) {
                        return { white: 100, black: 0, message: '흰색 승리!' };
                    } else if (gameResult.textContent.includes('검은색 승리')) {
                        return { white: 0, black: 100, message: '검은색 승리!' };
                    } else {
                        return { white: 50, black: 50, message: '무승부!' };
                    }
                }
            }

            // 체크 상황 확인
            const isCheck = document.querySelector('.board-square.legal-move') !== null;

            // 기본 승리 가능성 계산 (기물 가치 기반)
            let whiteWinChance = 50;
            let blackWinChance = 50;

            if (whiteMaterial > blackMaterial) {
                const materialAdvantage = (whiteMaterial - blackMaterial) / 9; // 최대 기물 가치로 정규화
                whiteWinChance = 50 + (materialAdvantage * 30); // 최대 80%
                blackWinChance = 100 - whiteWinChance;
            } else if (blackMaterial > whiteMaterial) {
                const materialAdvantage = (blackMaterial - whiteMaterial) / 9;
                blackWinChance = 50 + (materialAdvantage * 30);
                whiteWinChance = 100 - blackWinChance;
            }

            // 기물 수 고려
            if (whitePieces > blackPieces) {
                whiteWinChance += 5;
                blackWinChance -= 5;
            } else if (blackPieces > whitePieces) {
                blackWinChance += 5;
                whiteWinChance -= 5;
            }

            // 체크 상황 고려
            if (isCheck) {
                if (isWhiteTurn) {
                    blackWinChance += 10;
                    whiteWinChance -= 10;
                } else {
                    whiteWinChance += 10;
                    blackWinChance -= 10;
                }
            }

            // 확률 범위 제한
            whiteWinChance = Math.max(0, Math.min(100, whiteWinChance));
            blackWinChance = Math.max(0, Math.min(100, blackWinChance));

            // 메시지 생성
            let message = '';
            if (whiteWinChance > 60) {
                message = '흰색이 유리합니다';
            } else if (blackWinChance > 60) {
                message = '검은색이 유리합니다';
            } else {
                message = '균형잡힌 상황입니다';
            }

            return {
                white: Math.round(whiteWinChance),
                black: Math.round(blackWinChance),
                message: message,
                whiteMaterial: whiteMaterial,
                blackMaterial: blackMaterial
            };
        }

        // 승리 가능성 표시 업데이트
        function updateWinProbability() {
            const probability = calculateWinProbability();
            const winProbDiv = document.getElementById('winProbability');

            if (probability.message.includes('승리') || probability.message.includes('무승부')) {
                winProbDiv.innerHTML = `
                    <div style="font-weight: bold; color: #e74c3c; margin-bottom: 10px;">
                        ${probability.message}
                    </div>
                `;
            } else {
                winProbDiv.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>흰색: ${probability.white}%</span>
                            <span>검은색: ${probability.black}%</span>
                        </div>
                        <div style="background: #ecf0f1; height: 20px; border-radius: 10px; overflow: hidden;">
                            <div style="background: linear-gradient(90deg, #3498db ${probability.white}%, #e74c3c ${probability.white}%); height: 100%; width: 100%;"></div>
                        </div>
                        <div style="text-align: center; margin-top: 5px; font-size: 12px; color: #7f8c8d;">
                            ${probability.message}
                        </div>
                        <div style="font-size: 11px; color: #95a5a6; margin-top: 5px;">
                            기물 가치: 흰색 ${probability.whiteMaterial}, 검은색 ${probability.blackMaterial}
                        </div>
                    </div>
                `;
            }
        }

        // FEN 표시 업데이트
        function updateFEN(fen) {
            const fenDisplay = document.getElementById('fenDisplay');
            if (fenDisplay) {
                fenDisplay.innerHTML = `<code>${fen}</code>`;
            }
        }

        // 좌표를 SAN으로 변환
        function convertToSAN() {
            const coord1 = document.getElementById('fromCoord').value.toLowerCase();
            const coord2 = document.getElementById('toCoord').value.toLowerCase();
            const promotion = document.getElementById('promotionPiece').value;
            const resultDiv = document.getElementById('sanResult');

            if (!coord1 || !coord2) {
                resultDiv.innerHTML = '<span class="error">시작 위치와 도착 위치를 모두 입력해주세요.</span>';
                resultDiv.className = 'san-result error';
                return;
            }

            // 좌표 형식 검증
            const coordPattern = /^[a-h][1-8]$/;
            if (!coordPattern.test(coord1) || !coordPattern.test(coord2)) {
                resultDiv.innerHTML = '<span class="error">올바른 좌표 형식을 입력해주세요. (예: e2, a1)</span>';
                resultDiv.className = 'san-result error';
                return;
            }

            // API 호출
            fetch('/coordinates_to_san', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    coord1: coord1,
                    coord2: coord2,
                    promotion: promotion
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        let resultHTML = `
                        <div class="success">
                            <strong>SAN: ${data.san}</strong><br>
                            <small>UCI: ${data.uci}</small><br>
                            <small>기물: ${data.piece} (${data.analysis.piece_color === 'white' ? '흰색' : '검은색'})</small><br>
                            <small>이동 수: ${data.analysis.move_number}</small>
                    `;

                        if (data.is_capture) {
                            resultHTML += '<br><small>🎯 기물 잡기</small>';
                        }
                        if (data.is_check) {
                            resultHTML += '<br><small>⚡ 체크</small>';
                        }
                        if (data.is_checkmate) {
                            resultHTML += '<br><small>♔ 체크메이트!</small>';
                        }

                        resultHTML += '</div>';
                        resultDiv.innerHTML = resultHTML;
                        resultDiv.className = 'san-result success';
                    } else {
                        resultDiv.innerHTML = `<span class="error">오류: ${data.error}</span>`;
                        resultDiv.className = 'san-result error';
                    }
                })
                .catch(error => {
                    resultDiv.innerHTML = `<span class="error">네트워크 오류: ${error}</span>`;
                    resultDiv.className = 'san-result error';
                });
        }

        // Enter 키로 SAN 변환
        document.addEventListener('DOMContentLoaded', function () {
            const fromCoord = document.getElementById('fromCoord');
            const toCoord = document.getElementById('toCoord');

            if (fromCoord && toCoord) {
                fromCoord.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        toCoord.focus();
                    }
                });

                toCoord.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        convertToSAN();
                    }
                });
            }
        });

        // 합법적인 이동 표시 제거
        function clearLegalMoves() {
            const squares = document.querySelectorAll('.board-square');
            squares.forEach(square => {
                square.classList.remove('legal-move');
            });
        }



        // 수 두기
        function makeMove(fromSquare, toSquare) {
            fetch('/make_move', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    from_square: fromSquare,
                    to_square: toSquare
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateGameState(data.board_state);
                        updateBoard(data.board_state.fen);

                        // 수를 둔 후 타이머 재시작 (현재 차례에 맞춰서)
                        startTimer();
                    } else {
                        alert(data.error || '잘못된 수입니다.');
                    }
                })
                .catch(error => {
                    console.error('수 두기 오류:', error);
                    alert('수를 둘 수 없습니다.');
                });
        }

        // 게임 리셋
        function resetGame() {
            fetch('/reset_game')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentGame = null;
                        selectedSquare = null;
                        document.getElementById('gameSetup').classList.remove('hidden');
                        document.getElementById('gameBoard').classList.add('hidden');
                        clearSelection();

                        // 게임 종료 표시 숨기기
                        document.getElementById('gameOver').classList.add('hidden');

                        // 게임 상태 초기화
                        document.getElementById('gameStatus').textContent = '게임 준비 중';
                        document.getElementById('gameStatus').style.color = '#495057';
                        document.getElementById('gameStatus').style.fontWeight = 'normal';
                        document.getElementById('currentTurn').textContent = '';

                        // 타이머 리셋 및 정지
                        stopTimer();
                        resetTimer();

                        // 아두이노 타이머도 정지
                        stopArduinoTimer();
                    }
                })
                .catch(error => {
                    console.error('게임 리셋 오류:', error);
                });
        }

        // 무르기 (간단한 구현)
        function undoMove() {
            alert('무르기 기능은 현재 지원되지 않습니다.');
        }

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', function () {
            console.log('페이지 로드됨, 체스보드 초기화 시작');
            initializeBoard();
            console.log('체스보드 초기화 완료');

            // WebSocket 연결 시작
            connectWebSocket();
        });
    </script>
</body>

</html>